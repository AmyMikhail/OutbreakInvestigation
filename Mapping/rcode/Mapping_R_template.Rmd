---
title: "Outbreak Investigation Module (OIM)" 
subtitle: "Mapping in R: coding template"
date: "`r format(Sys.Date(), format = '%d %B %Y')`"
output: html_document
theme: sandstone
geometry: margin = 1.5cm
urlcolor: blue
always_allow_html: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      eval = TRUE,
                      message = FALSE, 
                      warning = FALSE, 
                      ft.align = "left",
                      fig.width = 12,
                      out.width = "100%")
```


\newpage

------------------------------------------------------------------------

# Introduction

This R markdown template is the workbook companion to the **Mapping in R: STEC raw milk case study**. The code chunks from the case study guide have been replicated here with minimal text. Participants should use this coding template to explore each code chunk and modify the code as needed in order to answer the questions in the case study guide.


### Installing R packages

```{r package_installs}

##################################################################
# INSTALL PACMAN PACKAGE

# Check if the 'pacman' package is installed, if not install it:
if (!requireNamespace("pacman", quietly = TRUE)) install.packages("pacman")


```


### Loading libraries

```{r package_loading}

##################################################################
# LOAD LIBRARIES

# Load the required libraries into the current R session:
pacman::p_load(rio,
               here,
               janitor,
               tidyverse,
               tidygeocoder,
               sf,
               osmdata,
               ggmap,
               scales,
               leaflet,
               htmlwidgets)

```


### Import data


**Importing case and population data**


```{r import csv files}

###########################################################################
# Import outbreak case linelist

# Import the outbreak case line list, which includes residence coordinates:
caselist <- rio::import(file = here("data", 
                                    "CaseStudy_RDM_anon_data_coords.csv")) %>%
  # Clean variable names:
  janitor::clean_names() %>% 
  
  # Create nice labels for the Raw drinking milk (RDM) cluster variable:
  dplyr::mutate(wgs_rdm_cluster = case_when(
    wgs_rdm_cluster == TRUE ~ "A. Raw milk cluster", 
    wgs_rdm_cluster == FALSE ~ "B. Other cluster")) 


###########################################################################
# Import population data for health regions

# Import the population data for health regions (called PHE centres):
region_pop <- rio::import(file = here("data", 
                                      "PHEC_population.csv")) %>% 
  
  # Clean variable names: 
  janitor::clean_names()

```


**Importing shape files for health regions:**

```{r import shape files}

# Import the shape files for 9 health regions (called PHEC or PHE Centres): 
region_sf <- sf::st_read(dsn = here("shapefiles", "En_PHE_Centre.shp")) %>% 
  
  # Clean variable names:
  janitor::clean_names()

```


**Transform coordinate reference system (CRS) to latitude and longitude:**


```{r}

region_sf <- sf::st_transform(x = region_sf, crs = 4326)

```


### Calculate crude incidence rates


```{r calculate incidence}

# Create the table of summary counts of cases by PHE Centre:
incidencetab <- caselist %>% 
  group_by(phecnm) %>% 
  summarise(cases = length(caseid))

# Add population data to the table:
incidencetab <- region_pop %>% 
  left_join(incidencetab, by = "phecnm")

# Change NA counts to 0 for incidence calculation:
incidencetab <- incidencetab %>% 
  mutate(cases = ifelse(is.na(cases), 0, cases))

# Calculate crude incidence per 100,000 population:
incidencetab <- incidencetab %>% 
  mutate(Incidence = round((cases/population)*100000, 2))

# Update the health regions shapefile by merging the incidence table with it:
region_sf <- region_sf %>% 
  left_join(incidencetab, by = "phecnm")

```

**Exploratory tasks:**

   + Inspect the `incidencetab` data.frame after each command to check what has changed

   + Try piping together all the commands to create the incidence table 
   + (hint: they are currently separated to make it easier to interogate each step)

   + Try rounding crude incidence to more or fewer decimal points
   + (hint: this is specified in `mutate(Incidence = round(..., 2))`).


### Importing map tiles from a web service


**Boundary box for map of UK**

```{r boundary box UK}

# First, define the boundaries of the map you want to import:
ukbb <- osmdata::getbb(place_name = "United Kingdom", featuretype = "country")


# Next, get the base layer map matching this boundary box: 
ukmap <- ggmap::get_map(location = ukbb, 
                        maptype = "terrain", 
                        source = "stamen")

# Have a quick look at the base map:
ggmap(ukmap)


```


**Boundary box for map of England:**

```{r boundary box England}

# First, define the boundaries of the map you want to import:
englandbb <- osmdata::getbb(place_name = "England", featuretype = "settlement")


# Next, get the base layer map matching this boundary box: 
englandmap <- ggmap::get_map(location = englandbb, 
                             maptype = "terrain", 
                             source = "stamen")

# Have a quick look at the base map:
ggmap(englandmap)

```


**Boundary box defined by data limits:**

```{r boundary box case coordinates}

# First define the boundary box with case coordinates:
cbbox <- ggmap::make_bbox(lon = home_long,
                          lat = home_lat, 
                          data = caselist,
                          f = 0.1)


# Next, get the base layer map matching this boundary box: 
coordinatesmap <- ggmap::get_map(location = cbbox, 
                                 maptype = "terrain", 
                                 source = "stamen")

# Have a quick look at the base map:
ggmap(coordinatesmap)

```

**Exploratory tasks:**

Note that when defining the boundary box, the `f` value (fraction by which the range should be extended beyond the minimum and maximum coordinates) will affect the zoom level of the map.  A higher resolution map will also include more place names at a lower administrative level.

   + Try changing the `f` value and see what looks best
   + Choose the base map that you think best defines the area of interest
   + (use this base map in the next section)



### Adding layers to map tiles:

**Point map with web tiles:**

```{r point map with web tiles}

# Fetch the selected base map tiles:
pointmap_web <- ggmap::ggmap(coordinatesmap, 
                             extent = 'panel', 
                             maprange = FALSE) +
  
  # Add case residence coordinates:
  geom_point(data = caselist, 
             aes(x = home_long, 
                 y = home_lat), 
             colour = "black",
             fill = "darkred",
             alpha = 0.5,
             size = 4, 
             shape = "circle filled", 
             show.legend = TRUE) +
  
  # Label x and y axes of map:
  labs(x = "Longitude", 
       y = "Latitude")
  
# Have a look at the map:
pointmap_web  

```


**Saving static maps:**

```{r}

# Save the map as a .pdf
ggplot2::ggsave(filename = "Map of cases - static.pdf", 
              plot = pointmap_web, 
              width = 9, 
              height = 9, 
              dpi = 300)


```


**Exploratory tasks:**

In the example code in this tutorial, we have only used one of the three addresses available for cases (their residence address, defined by `home_long` and `home_lat`).  The other two geocoded addresses available are for locations cases traveled to on a day trip (`travel_long` and `travel_lat`) and the location of likely exposure to the contaminated raw milk (`exposure_lat` and `exposure_long` - note this is a composit of the other two addresses).

   + Try recreating this case map, but use the exposure coordinates instead
   + (hint: change the x and y variables in the aes)
   + Repeat the case map again, but using the UK travel coordinates instead
   + Which coordinates do you think are most informative?



### Using shape files as the base map

**Shape file point map**

```{r point map with shape files}

# Plot an empty frame:
pointmap_sf <- ggplot2::ggplot() + 
  
  # Add the base map using health region shape files:
  geom_sf(data = region_sf, 
          colour = "black", 
          fill = "darkgreen",
          alpha = 0.5,
          size = 0.75) +
  
  # Add the case home residence coordinates:
  geom_point(data = caselist, 
             aes(x = home_long, 
                 y = home_lat), 
             colour = "black",
             fill = "darkred",
             alpha = 0.5,
             size = 4, 
             shape = "circle filled", 
             show.legend = TRUE) +
  
  # Label the x and y axes:
  labs(x = "Longitude", 
       y = "Latitude")

# View the map:
pointmap_sf

```


**Exploratory tasks:**

In this map, we first started with the shapefile layer, where we specified how we would like the base map to look (colour and thickness of region borders, fill colour and transparency).

   + Try changing the base map fill colour and transparency (alpha)
   + (hint: change the parameters in `geom_sf`)
   + Select the background map and points colour and transparency levels that work best.


## Stratified maps

### Stratifying by aesthetic attributes

**Stratified point map with web tiles:**

```{r stratified point map with web tiles}

# Create the base map from selected OpenStreetMap tiles:
stratamap_web <- ggmap::ggmap(coordinatesmap, 
                              extent = 'panel', 
                              maprange = FALSE) +
  
  # Add the case coordinates:
  geom_point(data = caselist, 
             aes(x = home_long, 
                 y = home_lat, 
                 fill = wgs_rdm_cluster), # Here we specify the stratifier
             colour = "black",
             alpha = 0.5,
             size = 4, 
             shape = "circle filled", 
             show.legend = TRUE) +
  
  # Label the x and y axes:
  labs(x = "Longitude", 
       y = "Latitude") + 
  
  # Manually specify the colours of each stratum:
  scale_fill_manual(values = c("darkred", 
                               "turquoise")) + 
  
  # Manually specify the title of the strata legend:
  labs(fill = "Whole genome sequencing cluster")

  
# Have a look at the map:
stratamap_web  


```


**Stratified point map with shape files:**


```{r stratified point map with shape files}

# Plot an empty frame:
stratamap_sf <- ggplot2::ggplot() + 
  
  # Add the base map using health region shape files:
  geom_sf(data = region_sf, 
          colour = "black", 
          fill = "darkgreen",
          alpha = 0.5,
          size = 0.75) +
  
  # Add the case home residence coordinates:
  geom_point(data = caselist, 
             aes(x = home_long, 
                 y = home_lat, 
                 fill = wgs_rdm_cluster), # Here we specify the stratifier
             colour = "black",
             alpha = 0.5,
             size = 4, 
             shape = "circle filled", 
             show.legend = TRUE) +
  
  # Label the x and y axes:
  labs(x = "Longitude", 
       y = "Latitude") +
  
  # Manually specify colours for strata levels:
  scale_fill_manual(values = c("darkred", 
                               "turquoise")) +
  
  # Manually specify legend title for strata:
  labs(fill = "Whole genome sequencing cluster:") 

# View the map:
stratamap_sf


```



**Exploratory tasks:**

In the two stratified maps, we specified how the points should look, with the `colour` (of shape border), `size`, `shape`, and `alpha` (transparency level of fill colour) arguments.  We also specified exactly which colours to use for the stratified variable with `scale_fill_manual()`. You can find more information about the different formatting options for points and other ggplot features by typing `vignette("ggplot2-specs")` in your R console (the vignette will open in the help pane of RStudio).

   + Try changing the `alpha` (transparency) - what effect does it have on overlapping points?
   + Try changing the `shape` to `circle` - what happens to the border colour of the points?
   + Try changing the variables to stratify on - what else could be interesting?
   + (hint: change the fill variable in aes)
   + (hint: make sure you provide enough colours for each factor level in `scale_fill_manual`)
   + (hint: change the title of the legend in `labs(fill = ...)`)


### Stratifying with facets:

**Faceted time series maps:**

```{r stratified point map time series}

# Facet the stratified shape file map by year:
tsmap <- stratamap_sf + facet_wrap(~year, 
                                   ncol = 3) +
  
  theme(legend.position = "bottom")

# View the maps:
tsmap

```


**Exploratory tasks:**

For this time series, we created a map for each year of the outbreak, but it may also be useful to stratify (facet) the maps by other variables.

   + Try faceting with a different variable from `caselist`
   + (hint: variable should have a limited number of factor levels)
   + (hint: change the variable name after the tilde in `facet_wrap(~...)`)
   + Try changing the layout of the facets to two columns and three rows
   + (hint: change the `ncol = ...` value inside the facet_wrap command)
   + (hint: add another argument `nrow = ...` inside the facet_wrap command)




## Density maps


### Contour and heat maps

**1. Contour map:**

```{r contourmap of case counts}

# Create an empty frame:
contourmap <- ggplot2::ggplot() + 
  
  # Add the base map (health region shape files):
  geom_sf(data = region_sf, 
          colour = "black", 
          fill = "darkgreen",
          alpha = 0.5,
          size = 0.75) +
  
  # Aggregate cases by density to create the contour lines:
  geom_density2d(data = caselist, 
                 mapping = aes(x = home_long, 
                               y = home_lat, 
                               alpha = ..level..),
                 contour_var = "count") # Count cases per grid square

# View the contour map:
contourmap

```


**Exploratory tasks:**

Note that the `alpha` argument inside the aes of `geom_density2d()` is using the density calculated by this function to set the transparency levels of the lines, with lines becoming stronger and less transparent the more dense the number of cases are.  Alternatively you can set it to a static value, like `0.5` which will make the transparency of the line equivalent to the midpoint of the densities on a scale from 0.1 (lowest density) to 1 (highest density).

   + Try varying the alpha argument inside `geom_density2d()` - what effect does this have?
     - (hint: change `alpha = ..level..` to `alpha = 0.5` for example)


**2. Heatmap:**


```{r heatmap of case counts}

# Create an empty frame:
heatmap <- ggplot2::ggplot() + 
  
  # Add the base map (health region shape file):
  geom_sf(data = region_sf, 
          colour = "black", 
          fill = "darkgreen",
          alpha = 0.5,
          size = 0.75) +
  
  # Add the case coordinates:
  stat_density2d(data = caselist, 
                 mapping = aes(x = home_long, 
                               y = home_lat, 
                               fill = ..level.., 
                               alpha = ..level..), 
                 size = 0.01,  
                 bins = 50, # Changing the bins will change how the map looks
                 geom = "polygon") + 
  
  # Define the colour gradient for the heatmap:
  scale_fill_gradient(low = "blue", 
                      high = "red") + 
  
  # Define the minimum and maximum transparency levels for the heatmap colours:
  scale_alpha(range = c(0, 0.5), 
              guide = "none") # This suppresses the transparency legend

# View the heatmap with colour levels:
heatmap

```


**Exploratory tasks:**

This map is quite similar to the previous one, but we have an extra option `bins` in the `stat_density2d()` function that we can use to control at what resolution case density is displayed.  

   + Try changing the `bins` argument in `stat_density2d()` - what effect does this have?
     - (hint: set `bins = 20` for example and compare with the previous map)
   + What is the danger of using a bins value that is too high for the data?
   + What is the danger of using a bins value that is too low for the data?
   + How would you calculate an appropriate bins number?
     - (hint: use the number of cases per region in the incidence table)
   
   + Try changing the colours that represent low and high density values
     - (hint: change the values for `low` and `high` in `scale_fill_gradient()`)



### Choropleth maps


```{r choropleth map of incidence}

# Create the choropleth map with shape file and incidence data:
cimap <- ggplot2::ggplot(region_sf) + 
  
  # Set the values to plot and fill the regions with as incidence:
  geom_sf(mapping = aes(fill = Incidence), 
          colour = "black", 
          size = 0.5) +
  
  # Specify how the fill colours should be set:
  scale_fill_distiller(
    # Use shades of blue for the fill
    palette = "Blues", 
    # Break up the incidence scale into 8 groups:
    breaks = scales::breaks_pretty(n = 8), 
    # Use the default order of colours (-1 to reverse):
    direction = 1) +
  
  # Set the legend title and colour order in the legend:
  guides(fill = guide_legend(title = "Crude incidence per 100 000", 
                             reverse = FALSE)) + 
  
  # Apply the ggplot theme_nothing to remove grid lines:
  theme_nothing(legend = TRUE)

# View the map:
cimap

```


**Exploratory tasks:**

This map is similar to the heat map in that darker colours (if you set them that way) are indicative of higher incidence.  However, this time we are adjusting for population density by using incidence per 100 000 population, and we are also restricting the colour changes to be within the bounds of the 9 regions.  

The heat map showed graduated differences between smaller areas that were estimated from the data, while this choropleth map shows discrete relative differences between regions, based on region-aggregated incidence.  As with the contour and heat maps, the number of bins (this time called `breaks`) will have an impact on how the incidence rates are displayed on the map.

   + Try reversing the order of the colours - what effect does this have?
     - (hint: change the `direction` argument to `-1` in `scale_fill_distiller()`)
   + Try increasing the number of breaks to 16 - what effect does this have?
     - (hint: change the number in the `breaks` argument of `scale_fill_distiller()`)
   


### Interactive maps

**Leaflet cluster map:**

```{r interactive map}

# Create the interactive map:
clustermap <- leaflet() %>% 
  
  # Add open street map (default base layer)
  addTiles(options = tileOptions(maxZoom = 18)) %>% 
  
  # Add transformed shapefile of regions
  addPolygons(data = region_sf, 
              weight = 5, 
              col = "black") %>% 
 
  # Add markers for case residence with descriptive labels:
  addMarkers(lng = caselist$home_long,
             lat = caselist$home_lat,
             popup = paste("ID: ", caselist$caseid, "<br/>",
                           "Epilink: ", caselist$epi_outbreak, "<br/>", 
                           "WGS cluster: ", caselist$wgs_rdm_cluster), 
             clusterOptions = markerClusterOptions()) 

# View the map:
clustermap

```


**Saving the interactive cluster map:**


```{r save html map}

# Save the map:
htmlwidgets::saveWidget(widget = clustermap, 
                        file = "Map of cases - interactive.html")


```



**Exploratory tasks:**

This interactive map also aggregates cases by density, but unlike the contour maps, heat maps and choropleth maps, we have less control over how much or in what way the data are being aggregated at each zoom level.  On the other hand, we can control how much the viewer can disaggregate the data.

   + Try changing the `maxZoom` level so that viewers cannot see individual buildings
     - (hint: reduce the number in `addTiles(options = tileOptions(maxZoom = ...))`)
   + Try changing some of the aesthetics (e.g. width of the region border lines)
     - (hint: change the `weight` argument in `addPolygons`)


------------------------------------------------------------------------

# Appendix

## A. Postcode cleaning


**Regular expression function to format UK postcodes:**

```{r add_space function}

# Function to ensure space between incode and outcode in postcodes:
add_space <- function(postcodevar){
  
  # If a space is present between incode and outcode, return as is:
  if(grepl(pattern = "?(\\s)", x = postcodevar) == TRUE){
    
    pcwithspace = postcodevar
  
    } else {
    # If a space is missing between incode and outcode, add one:
    pcwithspace = stringr::str_replace(string = postcodevar, 
                               pattern = "(?=.{3}$)",
                               replacement = " ")
    }
  # Return the postcodes with space added:
  return(pcwithspace)
}


```


**Applying the function to clean postcodes:**


```{r clean postcodes}

###############################################################################
# Read in the raw data set (where postcodes are not in the correct format):
caselist <- rio::import(file = here("data", "CaseStudy_RDM_anon_data.csv")) %>%
  
  # Procuess the following commands by row:
  rowwise() %>% 
  
  # Correct the format of the home residence postcodes:
  mutate(postcode_home = add_space(postcode_home)) %>% 
  
  # Correct the format of the UK travel (day trip) postcodes:
  mutate(postcode_uk_travel = add_space(postcode_uk_travel)) %>%
  
  # Correct the format of the exposure location postcodes:
  mutate(postcode_exposure = add_space(postcode_exposure))

```




## B. Geocoding


**Prepare data set for geocoding:**

```{r add_country}

# Import the raw data (contains clean postcodes but the are not yet geocoded):
caselist <- rio::import(file = here("data", 
                                    "CaseStudy_RDM_anon_data_cleanpcodes.csv")) %>%
  
  # Create a new column with the country name for the addresses to be geocoded:
  mutate(country = "UK")

```

**Perform geocoding:**

```{r geocode, eval=FALSE}
# Use the residential (home) postcodes and country to fetch geocoordinates:
caselist <- caselist %>% 
  
  # Geocode case residence postcodes:
  tidygeocoder::geocode(postalcode = postcode_home, 
                        country = country, 
                        method = "osm", 
                        lat = "home_lat", 
                        long = "home_long") %>% 
  
  # Geocode case UK travel (day trip) postcodes:
  tidygeocoder::geocode(postalcode = postcode_uk_travel, 
                        country = country, 
                        method = "osm", 
                        lat = "travel_lat", 
                        long = "travel_long") %>%
  
  # Geocode case exposure location postcodes:
  tidygeocoder::geocode(postalcode = postcode_exposure, 
                        country = country, 
                        method = "osm", 
                        lat = "exposure_lat", 
                        long = "exposure_long")

```
